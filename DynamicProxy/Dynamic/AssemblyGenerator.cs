using System.Collections.Concurrent;
using System.Reflection;
using System.Reflection.Emit;

namespace Umi.Proxy.Dynamic.Dynamic;

public static class AssemblyGenerator
{
    private const string NAME_SPACE_PREFIX = "Umi.Proxy.Dynamic.AutoGenerated";

    private static readonly string Suffix = Guid.NewGuid().ToString("N");

    public static string NameSpacePrefix => $"{NAME_SPACE_PREFIX}.{Suffix}";

    private static readonly IDictionary<Type, Type> GeneratedTypes;

    private static readonly ModuleBuilder ModuleBuilder;

    private static readonly Type AutoGeneratedBaseType = typeof(AutoGeneratedBase);

    static AssemblyGenerator()
    {
        GeneratedTypes = new ConcurrentDictionary<Type, Type>();
        AssemblyName assemblyName = new AssemblyName("MemoryAutoGeneratedAssembly");
        var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
        ModuleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName.Name + ".dll");
    }

    public static Type GetOrGenerateType(Type type)
    {
        if (type is not { IsInterface: true })
        {
            throw new ArgumentException($"{type.FullName} is not an interface");
        }

        return GeneratedTypes.GetOrDefault(type, () => GenerateType(type));
    }


    private static Type GenerateType(Type type)
    {
        var typeBuilder = ModuleBuilder.DefineType($"{NameSpacePrefix}.%%{type.Name}$AutoGenerated${Guid.NewGuid():N}",
            TypeAttributes.Class | TypeAttributes.Public | TypeAttributes.Sealed,
            AutoGeneratedBaseType);

        if (type.IsGenericType)
        {
            if (!type.IsGenericTypeDefinition)
            {
                type = type.GetGenericTypeDefinition();
            }

            var genericArguments = type.GetGenericArguments();
            var parameterBuilders = typeBuilder.DefineGenericParameters(genericArguments.Select(t => t.Name).ToArray());
            for (var i = 0; i < genericArguments.Length; i++)
            {
                parameterBuilders[i].SetBaseTypeConstraint(genericArguments[i].BaseType);
                parameterBuilders[i].SetGenericParameterAttributes(genericArguments[i].GenericParameterAttributes);
                parameterBuilders[i].SetInterfaceConstraints(genericArguments[i].GetInterfaces());
            }

            typeBuilder.AddInterfaceImplementation(type.MakeGenericType(parameterBuilders.Cast<Type>().ToArray()));
        }
        else
        {
            typeBuilder.AddInterfaceImplementation(type);
        }


        return new TypeGenerator(type, typeBuilder).Generate();
    }

    extension<TKey, TValue>(IDictionary<TKey, TValue> dictionary)
    {
        /// <summary>
        /// 获取字典值，如果不存在就返回默认值，并存入
        /// </summary>
        /// <param name="key">key</param>
        /// <param name="defaultValue">默认值</param>
        /// <returns>值</returns>
        private TValue GetOrDefault(TKey key, Func<TValue> defaultValue)
        {
            if (dictionary.TryGetValue(key, out var value)) return value;
            value = defaultValue();
            dictionary.Add(key, value);
            return value;
        }
    }
}