using System.Collections.Immutable;
using System.Reflection;
using System.Reflection.Emit;
using DynamicProxy;
using Umi.Proxy.Dynamic.Aspect;
using Umi.Proxy.Dynamic.Aspect.Invocations;

namespace Umi.Proxy.Dynamic.Dynamic;

internal class TypeGenerator
{
    // 把相关的帮助方法获取出来
    private readonly MethodInfo _typeGetTypeFromHandle;

    private readonly MethodInfo _methodGetMethodFromHandle;

    private readonly MethodInfo _parentMethod;

    private readonly ConstructorInfo _parentConstructor;

    private readonly ConstructorInfo _notSupportExceptionConstructor;

    private readonly MethodInfo _parentStaticMethod;

    private readonly Type _interfaceType;

    private readonly TypeBuilder _typeBuilder;

    private readonly IReadOnlyCollection<MethodInfo> _methods;
    private readonly IReadOnlyCollection<PropertyInfo> _propertyInfos;
    private readonly IReadOnlyCollection<EventInfo> _eventInfos;

    public TypeGenerator(Type type, TypeBuilder builder)
    {
        #region NormalInitial

        _typeGetTypeFromHandle = typeof(Type).GetMethod(nameof(Type.GetTypeFromHandle),
                                     BindingFlags.Static | BindingFlags.Public,
                                     [typeof(RuntimeTypeHandle)])
                                 ?? throw new InvalidOperationException("can not found helper method");
        _methodGetMethodFromHandle = typeof(MethodBase).GetMethod(nameof(MethodBase.GetMethodFromHandle),
                                         BindingFlags.Static | BindingFlags.Public,
                                         [typeof(RuntimeMethodHandle), typeof(RuntimeTypeHandle)])
                                     ?? throw new InvalidOperationException("can not found helper method");
        _notSupportExceptionConstructor = typeof(NotSupportedException).GetConstructor([typeof(string)])
                                          ?? throw new InvalidOperationException("can not found helper method");
        _parentMethod =
            typeof(AutoGeneratedBase).GetMethod("Process",
                BindingFlags.Instance | BindingFlags.NonPublic,
                [typeof(IMethodInvocation)])
            ?? throw new InvalidOperationException("can not found helper method");
        _parentStaticMethod = typeof(AutoGeneratedBase).GetMethod("ProcessStatic",
                                  BindingFlags.Static | BindingFlags.NonPublic,
                                  [typeof(IMethodInvocation)])
                              ?? throw new InvalidOperationException("can not found helper method");
        _parentConstructor =
            typeof(AutoGeneratedBase).GetConstructor(
                BindingFlags.CreateInstance | BindingFlags.NonPublic | BindingFlags.Instance,
                [typeof(IInvoker), typeof(IEnumerable<IInterceptor>)])
            ?? throw new InvalidOperationException("can not found helper method");
        _interfaceType = type ?? throw new ArgumentNullException(nameof(type));
        _typeBuilder = builder ?? throw new ArgumentNullException(nameof(builder));

        #endregion

        // 先吧 Property 和 Event
        IEnumerable<Type> targets = [type, ..type.GetInterfaces()];

        #region Properties And Event Initial And Method without accessor

        List<PropertyInfo> properties = [];
        List<EventInfo> events = [];
        List<MethodInfo> methodInfos = [];
        foreach (var target in targets)
        {
            var propertyInfos = target.GetProperties(BindingFlags.Public
                                                     | BindingFlags.NonPublic
                                                     | BindingFlags.Instance
                                                     | BindingFlags.Static);
            var eventInfos = target.GetEvents(BindingFlags.Public
                                              | BindingFlags.NonPublic
                                              | BindingFlags.Instance
                                              | BindingFlags.Static);
            properties.AddRange(propertyInfos);
            events.AddRange(eventInfos);
            var methods = target.GetMethods(BindingFlags.Public
                                            | BindingFlags.NonPublic
                                            | BindingFlags.Instance
                                            | BindingFlags.Static)
                .Where(p => propertyInfos.SelectMany(v => (IEnumerable<MethodInfo?>)[v.GetMethod, v.SetMethod])
                    .All(v => p != v))
                .Where(p => eventInfos
                    .SelectMany(v => (IEnumerable<MethodInfo?>)[v.AddMethod, v.RemoveMethod, v.RaiseMethod])
                    .All(v => p != v))
                .Where(p => p.IsVirtual);
            methodInfos.AddRange(methods);
        }

        _propertyInfos = properties.ToImmutableList();
        _eventInfos = events.ToImmutableList();
        _methods = methodInfos.ToImmutableList();

        #endregion
    }


    public Type Generate()
    {
        // 不生成field
        GeneratedConstructor();
        // 生成全部Method
        GeneratedMethods();
        // 生成全部Property
        GeneratedProperties();
        // 生成全部Event
        // Event 的 Add 和 Remove 的访问，应该 抛出 NotSupportedException, 我们不能在RPC 中触发远程事件
        GeneratedEvents();
        return _typeBuilder
            .CreateTypeInfo()
            .AsType();
    }

    private void GeneratedEvents()
    {
        // 我们应该忽略所有 非 Virtual 的，那不能覆盖
        foreach (var eventInfo in _eventInfos)
        {
            if (eventInfo is { EventHandlerType: null }
                or { AddMethod: { IsVirtual: false } }
                or { RemoveMethod: { IsVirtual: false } }
                or { RaiseMethod: { IsVirtual: false } })
            {
                continue;
            }

            var eventBuilder =
                _typeBuilder.DefineEvent(eventInfo.Name, eventInfo.Attributes, eventInfo.EventHandlerType);
            if (eventInfo.AddMethod is not null)
            {
                eventBuilder.SetAddOnMethod(EventAccessorGenerated(eventInfo.AddMethod));
            }

            if (eventInfo.RemoveMethod is not null)
            {
                eventBuilder.SetRemoveOnMethod(EventAccessorGenerated(eventInfo.RemoveMethod));
            }

            if (eventInfo.RaiseMethod is not null)
            {
                eventBuilder.SetRaiseMethod(EventAccessorGenerated(eventInfo.RaiseMethod));
            }
        }
    }

    private MethodBuilder EventAccessorGenerated(MethodInfo accessor)
    {
        var parameters = accessor.GetParameters().Select(p => p.ParameterType).ToArray();
        var attribute = accessor.Attributes ^ MethodAttributes.Abstract;
        if (accessor.IsStatic)
        {
            attribute = attribute ^ MethodAttributes.Virtual;
        }

        var methodBuilder = _typeBuilder.DefineMethod(accessor.Name,
            attribute,
            accessor.CallingConvention, accessor.ReturnType, parameters);
        methodBuilder.SetReturnType(accessor.ReturnType);
        _typeBuilder.DefineMethodOverride(methodBuilder, accessor);

        var il = methodBuilder.GetILGenerator();
        il.Emit(OpCodes.Ldstr, "RPC proxy can not support this operator");
        il.Emit(OpCodes.Newobj, _notSupportExceptionConstructor);
        il.Emit(OpCodes.Throw);

        methodBuilder.SetImplementationFlags(MethodImplAttributes.IL);
        return methodBuilder;
    }


    private void GeneratedProperties()
    {
        MethodBuilder ImplementAccessor(MethodInfo method)
        {
            var parameters = method.GetParameters().Select(p => p.ParameterType).ToArray();
            var attribute = method.Attributes ^ MethodAttributes.Abstract;
            if (method.IsStatic)
            {
                attribute = attribute ^ MethodAttributes.Virtual;
            }

            var methodBuilder = _typeBuilder.DefineMethod(method.Name,
                attribute,
                method.CallingConvention, method.ReturnType, parameters);
            methodBuilder.SetReturnType(method.ReturnType);
            _typeBuilder.DefineMethodOverride(methodBuilder, method);
            MethodImplement(methodBuilder, method);
            return methodBuilder;
        }

        foreach (var propertyInfo in _propertyInfos)
        {
            // 优先排除 no virtual 的 即  property 的 getter 或 setter 是 no  virtual 就不管它(
            if (propertyInfo is { GetMethod: { IsVirtual: false } } or { SetMethod: { IsVirtual: false } })
            {
                // 这个属性不能覆盖，是 sealed 的 不管它
                continue;
            }

            var propertyBuilder = _typeBuilder.DefineProperty(propertyInfo.Name, propertyInfo.Attributes,
                propertyInfo.PropertyType, propertyInfo.GetIndexParameters().Select(p => p.ParameterType).ToArray());
            // 实现它的accessors
            // 属性不用考虑泛型的（没有泛型的属性吧？）

            if (propertyInfo.GetMethod is not null)
            {
                propertyBuilder.SetGetMethod(ImplementAccessor(propertyInfo.GetMethod));
            }

            if (propertyInfo.SetMethod is not null)
            {
                propertyBuilder.SetSetMethod(ImplementAccessor(propertyInfo.SetMethod));
            }
        }
    }

    private void GeneratedConstructor()
    {
        var constructorBuilder = _typeBuilder.DefineConstructor(
            MethodAttributes.Public | MethodAttributes.HideBySig,
            CallingConventions.Standard | CallingConventions.HasThis,
            [typeof(IInvoker), typeof(IEnumerable<IInterceptor>)]);
        // public .ctor(Invoker arg1, IEnumerable<IInterceptor> arg2):base(arg1, arg2){}
        var generator = constructorBuilder.GetILGenerator();
        generator.Emit(OpCodes.Ldarg_0);
        generator.Emit(OpCodes.Ldarg_1);
        generator.Emit(OpCodes.Ldarg_2);
        generator.Emit(OpCodes.Call, _parentConstructor);
        generator.Emit(OpCodes.Ret);
        constructorBuilder.SetImplementationFlags(MethodImplAttributes.IL);
    }

    private void GeneratedMethods()
    {
        // 开始生成
        foreach (var method in _methods)
        {
            var parameters = method.GetParameters().Select(p => p.ParameterType).ToArray();
            var attribute = method.Attributes ^ MethodAttributes.Abstract;
            if (method.IsStatic)
            {
                attribute = attribute ^ MethodAttributes.Virtual;
            }

            var methodBuilder = _typeBuilder.DefineMethod(method.Name,
                attribute,
                method.CallingConvention, method.ReturnType, parameters);
            methodBuilder.SetReturnType(method.ReturnType);
            if (method.IsGenericMethod)
            {
                var genericArguments = method.GetGenericArguments();
                var genericParametersBuilder =
                    methodBuilder.DefineGenericParameters(genericArguments.Select(t => t.Name).ToArray());
                for (int i = 0; i < genericArguments.Length; i++)
                {
                    genericParametersBuilder[i].SetBaseTypeConstraint(genericArguments[i].BaseType);
                    genericParametersBuilder[i]
                        .SetGenericParameterAttributes(genericArguments[i].GenericParameterAttributes);
                    genericParametersBuilder[i].SetInterfaceConstraints(genericArguments[i].GetInterfaces());
                }
            }

            _typeBuilder.DefineMethodOverride(methodBuilder, method);
            MethodImplement(methodBuilder, method);
        }
    }

    private void MethodImplement(MethodBuilder methodBuilder, MethodInfo origin)
    {
        // 这里的方法实现
        /*
         *   Type interface = typeof(interface)
         *   MethodInfo method = methodof(origin)
         *   object[] arguments = [arg1, arg2, arg3 .....]
         *   Type[] argumentTypes = [typeof(ArgType1), typeof(ArgType2)...];
         *   Type[] genericTypes = [] // if not generic method otherwise [typeof(T1), typeof(T2), typeof(T3)....]
         *    这里将选择实现，Static 和 Instance 不一样
         *   IMethodInvocation invocation = new Implement(this, interface, method, arguments,argumentTypes, genericTypes, typeof(ReturnType))
         *   return base.Process(invocation) // 如果是静态的，就调用 AutoGeneratedBase.ProcessStatic(invocation)
         *   下面开始实现
         */
        var il = methodBuilder.GetILGenerator();
        il.DeclareLocal(typeof(object[]));
        il.DeclareLocal(typeof(Type[]));
        il.DeclareLocal(typeof(Type[]));
        il.DeclareLocal(typeof(IMethodInvocation));
        var parameters = origin.GetParameters();

        #region generate arguments array

        il.Emit(OpCodes.Ldc_I4, parameters.Length);
        il.Emit(OpCodes.Newarr, typeof(object));
        for (var i = 0; i < parameters.Length; i++)
        {
            il.Emit(OpCodes.Dup);
            il.Emit(OpCodes.Ldc_I4_S, i);
            il.Emit(OpCodes.Ldarg_S, i + 1);
            if (parameters[i].ParameterType is { IsValueType: true } or { IsGenericParameter: true })
            {
                il.Emit(OpCodes.Box, parameters[i].ParameterType);
            }

            il.Emit(OpCodes.Stelem_Ref);
        }

        il.Emit(OpCodes.Stloc_0);

        #endregion

        #region generate method parameters array

        il.Emit(OpCodes.Ldc_I4_S, parameters.Length);
        il.Emit(OpCodes.Newarr, typeof(Type));
        for (var i = 0; i < parameters.Length; i++)
        {
            il.Emit(OpCodes.Dup);
            il.Emit(OpCodes.Ldc_I4_S, i);
            il.Emit(OpCodes.Ldtoken, parameters[i].ParameterType);
            il.Emit(OpCodes.Call, _typeGetTypeFromHandle);
            il.Emit(OpCodes.Stelem_Ref);
        }

        il.Emit(OpCodes.Stloc_1);

        #endregion

        #region generate generic arguments type array

        if (!origin.IsGenericMethod)
        {
            il.Emit(OpCodes.Ldc_I4_0);
            il.Emit(OpCodes.Newarr, typeof(Type));
        }
        else
        {
            var arguments = origin.GetGenericArguments();
            il.Emit(OpCodes.Ldc_I4_S, arguments.Length);
            il.Emit(OpCodes.Newarr, typeof(Type));
            for (var i = 0; i < arguments.Length; i++)
            {
                il.Emit(OpCodes.Dup);
                il.Emit(OpCodes.Ldc_I4_S, i);
                il.Emit(OpCodes.Ldtoken, arguments[i]);
                il.Emit(OpCodes.Call, _typeGetTypeFromHandle);
                il.Emit(OpCodes.Stelem_Ref);
            }
        }

        il.Emit(OpCodes.Stloc_2);

        #endregion

        #region instance IMethodInvocation

        // 判断是否静态方法
        // 无 this ,初始化 StaticMethodInvocation
        // 参数
        /*
         * Type interfaceType,
           MethodInfo method,
           object[] arguments,
           Type[] argumentTypes,
           Type[] genericArguments,
           Type returnType
         */
        // instance , 多一个  object target, 在第一个 InstanceMethodInvocation
        if (!origin.IsStatic)
        {
            // 不是静态的，arg0 就是 this
            il.Emit(OpCodes.Ldarg_0);
        }

        // 其他通用的
        il.Emit(OpCodes.Ldtoken, _interfaceType);
        il.Emit(OpCodes.Call, _typeGetTypeFromHandle);
        // 0000000000000000000000000000000000000000000000
        il.Emit(OpCodes.Ldtoken, origin);
        il.Emit(OpCodes.Ldtoken, origin.DeclaringType ?? _interfaceType);
        il.Emit(OpCodes.Call, _methodGetMethodFromHandle);
        // 000000000000000000000000000000000000000000000
        il.Emit(OpCodes.Ldloc_0);
        il.Emit(OpCodes.Ldloc_1);
        il.Emit(OpCodes.Ldloc_2);
        // 00000000000000000000000000000000000000000000
        il.Emit(OpCodes.Ldtoken, origin.ReturnType);
        il.Emit(OpCodes.Call, _typeGetTypeFromHandle);
        //////////////////////////////////////////////////
        var constructor = origin.IsStatic
            ? typeof(StaticMethodInvocation).GetConstructors()[0]
            : typeof(InstanceMethodInvocation).GetConstructors()[0];
        il.Emit(OpCodes.Newobj, constructor);
        il.Emit(OpCodes.Stloc_3); // 复制栈区 IMethodInvocation
        if (origin.IsStatic)
        {
            il.Emit(OpCodes.Ldloc_3);
            il.Emit(OpCodes.Call, _parentStaticMethod);
        }
        else
        {
            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Ldloc_3);
            il.Emit(OpCodes.Call, _parentMethod);
        }

        #endregion


        if (origin.ReturnType != typeof(void))
        {
            il.Emit(OpCodes.Ldloc_3);
            il.Emit(OpCodes.Callvirt, typeof(IMethodInvocation)
                .GetProperty(nameof(IMethodInvocation.ReturnValue))!
                .GetMethod!);
            if (origin.ReturnType.IsValueType || origin.ReturnType.IsGenericParameter)
            {
                il.Emit(OpCodes.Unbox_Any, origin.ReturnType);
            }
        }

        il.Emit(OpCodes.Ret);

        methodBuilder.SetImplementationFlags(MethodImplAttributes.IL);
    }
}