using System.Reflection;
using System.Reflection.Emit;
using DynamicProxy;
using Umi.Proxy.Dynamic.Aspect;
using Umi.Proxy.Dynamic.Aspect.Invocations;

namespace Umi.Proxy.Dynamic.Dynamic;

internal class TypeGenerator
{
    // 把相关的帮助方法获取出来
    private readonly MethodInfo _typeGetTypeFromHandle;

    private readonly MethodInfo _methodGetMethodFromHandle;

    private readonly MethodInfo _parentMethod;

    private readonly ConstructorInfo _parentConstructor;

    private readonly MethodInfo _parentStaticMethod;

    private readonly Type _interfaceType;

    private readonly TypeBuilder _typeBuilder;

    public TypeGenerator(Type type, TypeBuilder builder)
    {
        _typeGetTypeFromHandle = typeof(Type).GetMethod(nameof(Type.GetTypeFromHandle),
                                     BindingFlags.Static | BindingFlags.Public,
                                     [typeof(RuntimeTypeHandle)])
                                 ?? throw new InvalidOperationException("can not found helper method");
        _methodGetMethodFromHandle = typeof(MethodInfo).GetMethod(nameof(MethodInfo.GetMethodFromHandle),
                                         BindingFlags.Static | BindingFlags.Public,
                                         [typeof(RuntimeMethodHandle), typeof(RuntimeTypeHandle)])
                                     ?? throw new InvalidOperationException("can not found helper method");

        _parentMethod =
            typeof(AutoGeneratedBase).GetMethod("Process",
                BindingFlags.Instance | BindingFlags.NonPublic,
                [typeof(IMethodInvocation)])
            ?? throw new InvalidOperationException("can not found helper method");

        _parentStaticMethod = typeof(AutoGeneratedBase).GetMethod("ProcessStatic",
                                  BindingFlags.Static | BindingFlags.NonPublic,
                                  [typeof(IMethodInvocation)])
                              ?? throw new InvalidOperationException("can not found helper method");

        _parentConstructor =
            typeof(AutoGeneratedBase).GetConstructor(
                BindingFlags.CreateInstance | BindingFlags.NonPublic | BindingFlags.Instance,
                [typeof(IInvoker), typeof(IEnumerable<IInterceptor>)])
            ?? throw new InvalidOperationException("can not found helper method");
        _interfaceType = type ?? throw new ArgumentNullException(nameof(type));
        _typeBuilder = builder ?? throw new ArgumentNullException(nameof(builder));
    }


    public Type Generate()
    {
        // 不生成field
        GeneratedConstructor();
        // 生成全部Method
        GeneratedMethods();

        return _typeBuilder
            .CreateTypeInfo()
            .AsType();
    }

    private void GeneratedConstructor()
    {
        var constructorBuilder = _typeBuilder.DefineConstructor(
            MethodAttributes.Public | MethodAttributes.HideBySig,
            CallingConventions.Standard | CallingConventions.HasThis,
            [typeof(IInvoker), typeof(IEnumerable<IInterceptor>)]);
        // public .ctor(Invoker arg1, IEnumerable<IInterceptor> arg2):base(arg1, arg2){}
        var generator = constructorBuilder.GetILGenerator();
        generator.Emit(OpCodes.Ldarg_0);
        generator.Emit(OpCodes.Ldarg_1);
        generator.Emit(OpCodes.Ldarg_2);
        generator.Emit(OpCodes.Call, _parentConstructor);
        generator.Emit(OpCodes.Ret);
        constructorBuilder.SetImplementationFlags(MethodImplAttributes.IL);
    }

    private void GeneratedMethods()
    {
        List<MethodInfo> methods = new(_interfaceType.GetMethods(BindingFlags.Static | BindingFlags.Instance));
        foreach (var @interface in _interfaceType.GetInterfaces())
        {
            methods.AddRange(@interface.GetMethods(BindingFlags.Static | BindingFlags.Instance));
        }

        // 开始生成
        foreach (var method in methods)
        {
            var parameters = method.GetParameters().Select(p => p.ParameterType).ToArray();
            MethodBuilder methodBuilder;
            if (method.IsStatic)
            {
                methodBuilder = _typeBuilder.DefineMethod(method.Name,
                    MethodAttributes.Public | MethodAttributes.Static,
                    CallingConventions.Standard, method.ReturnType, parameters);
            }
            else
            {
                methodBuilder = _typeBuilder.DefineMethod(method.Name,
                    MethodAttributes.Public | MethodAttributes.Final,
                    CallingConventions.Standard | CallingConventions.HasThis, method.ReturnType, parameters);
            }

            if (method.IsGenericMethod)
            {
                var genericArguments = method.GetGenericArguments();
                var genericParametersBuilder =
                    methodBuilder.DefineGenericParameters(genericArguments.Select(t => t.Name).ToArray());
                for (int i = 0; i < genericArguments.Length; i++)
                {
                    genericParametersBuilder[i].SetBaseTypeConstraint(genericArguments[i].BaseType);
                    genericParametersBuilder[i]
                        .SetGenericParameterAttributes(genericArguments[i].GenericParameterAttributes);
                    genericParametersBuilder[i].SetInterfaceConstraints(genericArguments[i].GetInterfaces());
                }
            }

            _typeBuilder.DefineMethodOverride(methodBuilder, method);
            MethodImplement(methodBuilder, method);
            methodBuilder.SetReturnType(method.ReturnType);
        }
    }

    private void MethodImplement(MethodBuilder methodBuilder, MethodInfo origin)
    {
        // 这里的方法实现
        /*
         *   Type interface = typeof(interface)
         *   MethodInfo method = methodof(origin)
         *   object[] arguments = [arg1, arg2, arg3 .....]
         *   Type[] argumentTypes = [typeof(ArgType1), typeof(ArgType2)...];
         *   Type[] genericTypes = [] // if not generic method otherwise [typeof(T1), typeof(T2), typeof(T3)....]
         *    这里将选择实现，Static 和 Instance 不一样
         *   IMethodInvocation invocation = new Implement(this, interface, method, arguments,argumentTypes, genericTypes, typeof(ReturnType))
         *   return base.Process(invocation) // 如果是静态的，就调用 AutoGeneratedBase.ProcessStatic(invocation)
         *   下面开始实现
         */
        var il = methodBuilder.GetILGenerator();
        il.DeclareLocal(typeof(object[]));
        il.DeclareLocal(typeof(Type[]));
        il.DeclareLocal(typeof(Type[]));
        il.DeclareLocal(typeof(IMethodInvocation));
        var parameters = origin.GetParameters();

        #region generate arguments array

        il.Emit(OpCodes.Ldc_I4, parameters.Length);
        il.Emit(OpCodes.Newarr, typeof(object));
        for (var i = 0; i < parameters.Length; i++)
        {
            il.Emit(OpCodes.Dup);
            il.Emit(OpCodes.Ldc_I4_S, i);
            il.Emit(OpCodes.Ldarg_S, i + 1);
            if (parameters[i].ParameterType is { IsValueType: true } or { IsGenericParameter: true })
            {
                il.Emit(OpCodes.Box, parameters[i].ParameterType);
            }

            il.Emit(OpCodes.Stelem_Ref);
        }

        il.Emit(OpCodes.Stloc_0);

        #endregion

        #region generate method parameters array

        il.Emit(OpCodes.Ldc_I4_S, parameters.Length);
        il.Emit(OpCodes.Newarr, typeof(Type));
        for (var i = 0; i < parameters.Length; i++)
        {
            il.Emit(OpCodes.Dup);
            il.Emit(OpCodes.Ldc_I4_S, i);
            il.Emit(OpCodes.Ldtoken, parameters[i].ParameterType);
            il.Emit(OpCodes.Call, _typeGetTypeFromHandle);
            il.Emit(OpCodes.Stelem_Ref);
        }

        il.Emit(OpCodes.Stloc_1);

        #endregion

        #region generate generic arguments type array

        if (!origin.IsGenericMethod)
        {
            il.Emit(OpCodes.Ldc_I4_0);
            il.Emit(OpCodes.Newarr, typeof(Type));
        }
        else
        {
            var arguments = origin.GetGenericArguments();
            il.Emit(OpCodes.Ldc_I4_S, arguments.Length);
            il.Emit(OpCodes.Newarr, typeof(Type));
            for (var i = 0; i < arguments.Length; i++)
            {
                il.Emit(OpCodes.Dup);
                il.Emit(OpCodes.Ldc_I4_S, i);
                il.Emit(OpCodes.Ldtoken, arguments[i]);
                il.Emit(OpCodes.Call, _typeGetTypeFromHandle);
                il.Emit(OpCodes.Stelem_Ref);
            }
        }

        il.Emit(OpCodes.Stloc_2);

        #endregion

        #region instance IMethodInvocation

        // 判断是否静态方法
        // 无 this ,初始化 StaticMethodInvocation
        // 参数
        /*
         * Type interfaceType,
           MethodInfo method,
           object[] arguments,
           Type[] argumentTypes,
           Type[] genericArguments,
           Type returnType
         */
        // instance , 多一个  object target, 在第一个 InstanceMethodInvocation
        if (!origin.IsStatic)
        {
            // 不是静态的，arg0 就是 this
            il.Emit(OpCodes.Ldarg_0);
        }

        // 其他通用的
        il.Emit(OpCodes.Ldtoken, _interfaceType);
        il.Emit(OpCodes.Call, _typeGetTypeFromHandle);
        // 0000000000000000000000000000000000000000000000
        il.Emit(OpCodes.Ldtoken, origin);
        il.Emit(OpCodes.Ldtoken, origin.DeclaringType ?? _interfaceType);
        il.Emit(OpCodes.Call, _methodGetMethodFromHandle);
        // 000000000000000000000000000000000000000000000
        il.Emit(OpCodes.Ldloc_0);
        il.Emit(OpCodes.Ldloc_1);
        il.Emit(OpCodes.Ldloc_2);
        // 00000000000000000000000000000000000000000000
        il.Emit(OpCodes.Ldtoken, origin.ReturnType);
        il.Emit(OpCodes.Call, _typeGetTypeFromHandle);
        //////////////////////////////////////////////////
        var constructor = origin.IsStatic
            ? typeof(StaticMethodInvocation).GetConstructors()[0]
            : typeof(InstanceMethodInvocation).GetConstructors()[0];
        il.Emit(OpCodes.Newobj, constructor);
        il.Emit(OpCodes.Stloc_3); // 复制栈区 IMethodInvocation
        if (origin.IsStatic)
        {
            il.Emit(OpCodes.Ldloc_3);
            il.Emit(OpCodes.Call, _parentStaticMethod);
        }
        else
        {
            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Ldloc_3);
            il.Emit(OpCodes.Call, _parentMethod);
        }

        #endregion


        if (origin.ReturnType != typeof(void))
        {
            il.Emit(OpCodes.Ldloc_3);
            il.Emit(OpCodes.Callvirt, typeof(IMethodInvocation)
                .GetProperty(nameof(IMethodInvocation.ReturnValue))!
                .GetMethod!);
            if (origin.ReturnType.IsValueType || origin.ReturnType.IsGenericParameter)
            {
                il.Emit(OpCodes.Unbox_Any, origin.ReturnType);
            }
        }

        il.Emit(OpCodes.Ret);

        methodBuilder.SetImplementationFlags(MethodImplAttributes.IL);
    }
}